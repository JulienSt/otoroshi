
  
"""
Settings for connection to an elastic cluster
"""
type ElasticAnalyticsConfig {
 clusterUri: String # Cluster URL
 headers: Json # Additionnal headers in the http request
 password: String
 indexSettings: IndexSettings # Indexation settings
 mtlsConfig: MtlsConfig # TLS settings for the http client
 index: String
 type: String
 applyTemplate: Boolean # Enable template creation/update
 version: String
 user: String
}

  
type CorsSettings {
 enabled: Boolean 
 allowCredentials: Boolean 
 maxAge: String
 allowMethods: [String] 
 allowHeaders: [String] 
 excludedPatterns: [String] 
 exposeHeaders: [String] 
 allowOrigin: String 
}

  
"""
Settings to transform a jwt token
"""
type MappingSettings {
 map: Json # Change values
 values: Json # Add values
 remove: [String] # Remove some token claims
}

  
"""
jwt token verification settings
"""
type VerificationSettings {
 fields: Json # Fields validation
 arrayFields: Json # Fields array validation
}

  
"""
A route representation with it's minimal attributes
"""
type NgMinimalRoute {
 backend_ref: String
 frontend: NgFrontend # The frontend of the route
 override_plugins: Boolean # Override global plugin list from route composition
 backend: NgMinimalBackend # The backend of the route
}

  
type MtlsConfig {
 mtls: Boolean 
 loose: Boolean 
 trustAll: Boolean 
 trustedCerts: [String] 
 certs: [String] 
}

  
type CustomTimeouts {
 path: String 
 callAndStreamTimeout: Int 
 callTimeout: Int 
 idleTimeout: Int 
 globalTimeout: Int 
 connectionTimeout: Int 
}

  
type BasicAuthConstraints {
 enabled: Boolean 
 headerName: String
 queryName: String
}

  
"""
Settings for apikey quotas alerts
"""
type QuotasAlmostExceededSettings {
 enabled: Boolean # Is quotas alert enabled
 dailyQuotasThreshold: Int # The daily quotas threshold before generating alert
 monthlyQuotasThreshold: Int # The monthly quotas threshold before generating alert
}

  
"""
An otoroshi model for a team of users in the organization (otoroshi-ui)
"""
type Team {
 tags: [String] # Entity tags
 name: String # Entity name
 description: String # Entity description
 tenant: String # Entity organization
 metadata: Json # Entity metadata
 id: String # Entity id
}

  
"""
Settings to enable chaos engineering for a service
"""
type ChaosConfig {
 badResponsesFaultConfig: String # Settings for bad responses
 largeRequestFaultConfig: String # Settings for large requests
 largeResponseFaultConfig: String # Settings for large responses
 latencyInjectionFaultConfig: String # Settings for latency injection
 enabled: Boolean # Whether or not this config is enabled
}

  """
  Version of the challenge token
  """
  enum SecComVersion { 
   V1
 v2
  }

  
"""
jwt token transformation settings
"""
type TransformSettings {
 _loc: Json # Location of the token
 mappingSettings: MappingSettings # Token mapping settings
}

  
"""
An otoroshi apikey that can allow you to access some services
"""
type ApiKey {
 dailyQuota: Int # Authorized number of calls per day
 metadata: Json # Bunch of metadata for the key
 throttlingQuota: Int # Authorized number of calls per second, measured on 10 seconds
 constrainedServicesOnly: Boolean # This apikey can only be used on services that constrained their apikey routing
 allowClientIdOnly: Boolean # This apikey can be used juste with the client_id value
 _loc: EntityLocation # The location of the apikey
 restrictions: Restrictions # Apikey restrictions settings
 tags: [String] # Apikey tags
 enabled: Boolean # Whether or not the key is enabled. If disabled, resources won't be available to calls using this key
 readOnly: Boolean # The apikey only allow access for GET, HEAD and OPTIONS verbs
 clientSecret: String # The secret of the Api Key. Usually 64 random alpha numerical characters, but can be anything
 validUntil: String
 clientName: String # The name of the api key, for humans ;-)
 monthlyQuota: Int # Authorized number of calls per month
 description: String # Description of this apikey
 rotation: ApiKeyRotation # Apikey rotation settings
 authorizedEntities: [String] # The group/service ids (prefixed by group_ or service_ on which the key is authorized
 clientId: String # The unique id of the Api Key. Usually 16 random alpha numerical characters, but can be anything
}

  
"""
Represent a user right (teams, organizations) in otoroshi-ui
"""
type UserRight {
 tenant: TenantAccess # Access rights on organizations
 teams: [TeamAccess] # Access rights on teams
}

  
"""
Otoroshi model for JWT token verifier
"""
type GlobalJwtVerifier {
 metadata: Json # Entity metadata
 algoSettings: Json # Algo settings of the verifier
 name: String # Verifier name
 source: Json # Where to find the jwt token
 id: String # Verifier id
 type: String # the kind of verifier
 strict: Boolean # Does it fail if JWT not found
 strategy: Json # The strategy of the verifier
 _loc: EntityLocation # Entity location
 desc: String # Verifier description
 tags: [String] # Entity tags
}

  
"""
Access rights for organizations
"""
type TenantAccess {
 canWrite: Boolean # Can this access right write data
 value: String # Access pattern
 canRead: Boolean # Can this access right read data
}

  
"""
The template that will be merged with newly created entities
"""
type DefaultTemplates {
 team: String
 script: String
 apikey: String
 group: String
 tcpService: String
 verifier: String
 service: String
 target: String
 certificate: String
 dataExporter: String
 route: String
 backend: String
 template: String
 tenant: String
 authConfig: String
 descriptor: String
}

  
type SAMLSignature {
 algorithm: Json 
 canocalizationMethod: Json 
}

  
"""
Filter events to export
"""
type DataExporterConfigFiltering {
 include: [Json] # Event include filter
 exclude: [Json] # Event exclude filter
}

  
"""
The otoroshi model for a group of services
"""
type ServiceGroup {
 id: String # A unique random string to identify your service
 _loc: EntityLocation # Entity location
 name: String # The name of your service. Only for debug and human readability purposes
 metadata: Json # Just a bunch of random properties
 description: String # Entity description
 tags: [String] # Entity tags
}

  
"""
An otoroshi plugins stored as scala code in the otoroshi datastore
"""
type Script {
 name: String # The name of the script
 metadata: Json # Entity metadata
 tags: [String] # Entity tags
 _loc: EntityLocation # Entity location
 desc: String # The description of the script
 code: String # The code of the script
 id: String # The id of the script
 type: Json # Plugin type
}

  
type SecComHeaders {
 claimRequestName: String
 stateRequestName: String
 stateResponseName: String
}

  
type SAMLCredentials {
 signingKey: Credential 
 encryptionKey: Credential 
 signedDocuments: Boolean 
 encryptedAssertions: Boolean 
}

  
"""
A target that can be stored in the otoroshi datastore
"""
type StoredNgTarget {
 name: String # The name of the target
 _loc: EntityLocation # The location of the target
 metadata: Json # The metadata of the target
 description: String # The description of the target
 tags: [String] # The tags of the target
 id: String # The id of the target
 target: NgTarget # The actual target
}

  
"""
Access rights for teams
"""
type TeamAccess {
 canRead: Boolean # Can this access right read data
 value: String # Access pattern
 canWrite: Boolean # Can this access right write data
}

  
"""
The otoroshi model for X509 certificates
"""
type Cert {
 certType: String # the kind of certificate
 metadata: Json # Entity metadata
 subject: String # Certificate subject
 letsEncrypt: Boolean # Let's encrypt (ACME) generated
 keypair: Boolean # Is cert used for its keypair only ?
 description: String # Entity description
 revoked: Boolean # Certificate is revoked
 valid: Boolean # Is cert valid
 password: String
 autoRenew: Boolean # Auto renew cert
 exposed: Boolean # Is the cert exposed (public key exposed in jwks.json)
 client: Boolean # Is cert a client cert ?
 from: Int # Start date
 selfSigned: Boolean # Is cert self signed
 id: String # Entity id
 ca: Boolean # Is cert a CA ?
 chain: String # Certicates chain (PEM encoded)
 sans: [String] # Certificate SANs
 _loc: EntityLocation # Entity location
 tags: [String] # Entity tags
 privateKey: String # Certificate private key (PEM encoded)
 caRef: String
 domain: String # Certificate domain
 name: String # Entity name
 to: Int # Stop date
}

  
"""
Associate targets for a domain (SNI)
"""
type TcpRule {
 domain: String # match on SNI domain
 targets: [TcpTarget] # TCP targets
}

  
type Canary {
 enabled: Boolean 
 traffic: Int 
 targets: [Target] 
 root: String 
}

  
"""
Settings for a bad response return (chaos engineering)
"""
type BadResponse {
 status: Int # The HTTP status for the response
 body: String # The body of the HTTP response
 headers: Json # The HTTP headers of the response
}

  
"""
A routing primitive representing how a request is matched and where the request is forwarded
"""
type NgRoute {
 debug_flow: Boolean # Enable report debugging
 enabled: Boolean # Is the route enabled
 name: String # The name of the route
 id: String # The ud of the route
 export_reporting: Boolean # Export the execution reporting through standard data exporter
 metadata: Json # The metadata of the route
 frontend: NgFrontend # The frontend of the route
 _loc: EntityLocation # The location of the route
 tags: [String] # The tags of the route
 capture: Boolean # Capture http traffic
 groups: [String] # The groups of the route
 backend_ref: String
 description: String # The description of the route
 backend: NgBackend # The backend of the route
}

  
"""
The global config (dynamic) for otoroshi
"""
type GlobalConfig {
 geolocationSettings: Json # Settings for geolocation extraction
 alertsEmails: [String] # Email addresses that will receive all Otoroshi alert events
 throttlingQuota: Int # Authorized number of calls per second globally, measured on 10 seconds
 maxWebhookSize: Int # Max number of items in webhooks
 maxConcurrentRequests: Int # The number of authorized request processed at the same time
 cleverSettings: String # Optional CleverCloud configuration
 templates: DefaultTemplates # The otoroshi default templates for entities
 endlessIpAddresses: [String] # IP addresses for which any request to Otoroshi will respond with 128 Gb of zeros
 plugins: Plugins # global plugins settings
 kafkaConfig: String # Global kafka settings. deprecated
 maxLogsSize: Int # Number of events kept locally
 proxies: Proxies # Web proxies settings
 enableEmbeddedMetrics: Boolean # Enable embedded metrics
 elasticReadsConfig: String # Config. for elastic reads
 trustXForwarded: Boolean # Use X-Forwarded-* headers for routing
 quotasSettings: QuotasAlmostExceededSettings # Settings to generate alert when an apikey almost exceeded or exceeded its quotas
 tags: [String] # Entity tags
 limitConcurrentRequests: Boolean # If enabled, Otoroshi will reject new request if too much at the same time
 useAkkaHttpClient: Boolean # Globally use akka http client for everything
 elasticWritesConfigs: [ElasticAnalyticsConfig] # Configs. for Elastic writes
 logAnalyticsOnServer: Boolean # Log analytics event on the server
 metadata: Json # Entity metadata
 apiReadOnly: Boolean # If enabled, Admin API won't be able to write/update/delete entities
 backOfficeAuthRef: String
 streamEntityOnly: Boolean # HTTP will be streamed only. Doesn't work with old browsers
 otoroshiId: String # Unique id for this otoroshi instance
 mailerSettings: String # Optional mailer configuration
 lines: [String] # Possibles lines for Otoroshi
 middleFingers: Boolean # Use middle finger emoji as a response character for endless HTTP responses
 analyticsWebhooks: [Webhook] # Webhook that will receive all internal Otoroshi events
 autoCert: AutoCert # Auto certs settings
 maintenanceMode: Boolean # Global maintenant mode
 letsEncryptSettings: LetsEncryptSettings # Let's encrypt (ACME) settings
 snowMonkeyConfig: SnowMonkeyConfig # Snowmonky settings
 scripts: GlobalScripts # global plugins settings. will be deprecated soon
 perIpThrottlingQuota: Int # Authorized number of calls per second globally per IP address, measured on 10 seconds
 useCircuitBreakers: Boolean # If enabled, services will be authorized to use circuit breakers
 maxHttp10ResponseSize: Int # The max size in bytes of an HTTP 1.0 response
 tlsSettings: TlsSettings # TLS settings
 statsdConfig: String # Statsd settings (agent connection)
 autoLinkToDefaultGroup: Boolean # If not defined, every new service descriptor will be added to the default group
 alertsWebhooks: [Webhook] # Webhook that will receive all Otoroshi alert events
 ipFiltering: IpFiltering # Global ip filtering settings
 u2fLoginOnly: Boolean # If enabled, login to backoffice through Auth0 will be disabled
 userAgentSettings: UserAgentSettings # Settings for useragent extraction
}

  
"""
Settings for generating a keypair
"""
type GenKeyPairQuery {
 algo: String # Keypair algorithm
 size: Int # Keypair size
}

  
"""
Representation of how a request will be matched to a route
"""
type NgFrontend {
 headers: Json # the headers that will be matched
 query: Json # the query params that will be matched
 domains: [String] # The domain and path that will be matched
 methods: [String] # the http methods that will be matched
 exact: Boolean # Match on exact path ?
 strip_path: Boolean # Is path stripped from backend request
}

  
type ClientIdAuthConstraints {
 enabled: Boolean 
 headerName: String
 queryName: String
}

  
type BasicAuthUser {
 metadata: Json 
 password: String 
 tags: [String] 
 email: String 
 webauthn: String 
 rights: UserRights 
 name: String 
}

  
type ClientConfig {
 connectionTimeout: Int 
 useCircuitBreaker: Boolean 
 retryInitialDelay: Int 
 cacheConnectionSettings: CacheConnectionSettings 
 proxy: Json 
 callTimeout: Int 
 callAndStreamTimeout: Int 
 globalTimeout: Int 
 maxErrors: Int 
 retries: Int 
 backoffFactor: Int 
 customTimeouts: [CustomTimeouts] 
 idleTimeout: Int 
 sampleInterval: Int 
}

  
type ApiKeyConstraints {
 customHeadersAuth: CustomHeadersAuthConstraints 
 routing: ApiKeyRouteMatcher 
 clientIdAuth: ClientIdAuthConstraints 
 jwtAuth: JwtAuthConstraints 
 basicAuth: BasicAuthConstraints 
}

  
"""
An otoroshi admin user
"""
type SimpleOtoroshiAdmin {
 createdAt: Int # User creation date
 metadata: Json # Entity metadata
 password: String # User password (bcrypt hashed)
 rights: UserRights # User rights
 typ: Json # Type of user
 label: String # User label
 type: String # the kind of admin
 _loc: EntityLocation # Entity location
 username: String # User username
 tags: [String] # Entity tags
}

  
"""
Represent a list of user rights
"""
type UserRights {
 rights: [UserRight] # Access rights of a user
}

  
"""
Settings for plugins (of any kind)
"""
type Plugins {
 config: Json # Plugins configuration
 enabled: Boolean # Plugins enabled
 excluded: [String] # Excluded paths
 refs: [String] # Enabled plugins
}

  
"""
A backend representation with it's minimal attributes
"""
type NgMinimalBackend {
 root: String # The root path of the backend or the full rewrite path
 targets: [NgTarget] # The targets of the backend
 load_balancing: LoadBalancing # Loadbalancing config og the backend
 target_refs: [String] # List of NgStoredBackend ids
 rewrite: Boolean # Does the backend performs a full url rewrite ?
}

  
"""
Target for a TCP proxy
"""
type TcpTarget {
 host: String # Target host
 ip: String
 port: Int # Target port
 tls: Boolean # Use tls
}

  
type GeoPositionRadius {
 latitude: Int 
 longitude: Int 
 radius: Int 
}

  
"""
Model for a TCP proxy
"""
type TcpService {
 enabled: Boolean # Service enabled
 description: String # Entity description
 metadata: Json # Entity metadata
 port: Int # network port
 tags: [String] # Entity tags
 rules: [TcpRule] # Routing rules
 clientAuth: Json # Use client authentication
 interface: String # Network interface
 sni: SniSettings # SNI settings
 id: String # Entity id
 _loc: EntityLocation # Entity location
 name: String # Entity name
 tls: Json # TLS mode
}

  
type GzipConfig {
 compressionLevel: Int 
 blackList: [String] 
 chunkedThreshold: Int 
 excludedPatterns: [String] 
 bufferSize: Int 
 whiteList: [String] 
 enabled: Boolean 
}

  
"""
Settings for webhook call
"""
type Webhook {
 headers: Json # Headers to authorize the call or whatever
 mtlsConfig: MtlsConfig # TLS config when calling webhook
 type: String # the kind of exporter
 url: String # The URL where events are posted
}

  
"""
Custom timeouts per path
"""
type NgCustomTimeouts {
 connection_timeout: Int # Timeout at connection
 call_and_stream_timeout: Int # Specify how long each call should last at most in milliseconds (hard timeout, connection will be closed after that duration)
 path: String # path on which this configuration works
 call_timeout: Int # Specify how long each call should last at most in milliseconds (soft timeout as it's enforced by the circuit breaker)
 idle_timeout: Int # Timeout on idle connection
 global_timeout: Int # Specify how long the global call (with retries) should last at most in milliseconds
}

  
"""
Remaining quotas for an apikey
"""
type RemainingQuotas {
 currentCallsPerSec: Int # Current number of call per second
 remainingCallsPerSec: Int # Remaining number of call per second
 currentCallsPerDay: Int # Current number of call per day
 authorizedCallsPerDay: Int # Number of authorized call per day
 currentCallsPerMonth: Int # Current number of call per month
 remainingCallsPerMonth: Int # Remaining number of call per month
 authorizedCallsPerSec: Int # Number of authorized call per second
 authorizedCallsPerMonth: Int # Number of authorized call per month
 remainingCallsPerDay: Int # Remaining number of call per day
}

  
"""
Settings to apply plugins globally
"""
type GlobalScripts {
 jobConfig: Json # jobs enabled
 enabled: Boolean # Global scripts enabled
 transformersConfig: Json # transformers config
 transformersRefs: [String] # transformers enabled
 preRouteRefs: [String] # pre-route plugins enabled
 sinkConfig: Json # sinks config
 jobRefs: [String] # running jobs
 validatorRefs: [String] # validator enabled
 sinkRefs: [String] # sinks enabled
 preRouteConfig: Json # pre-route config
 validatorConfig: Json # validator config
}

  
type JwtAuthConstraints {
 keyPairSigned: Boolean 
 cookieName: String
 queryName: String
 headerName: String
 secretSigned: Boolean 
 maxJwtLifespanSecs: String
 enabled: Boolean 
 includeRequestAttributes: Boolean 
}

  
"""
A backend that can be stored in the otoroshi datastore
"""
type StoredNgBackend {
 description: String # The description of the backend
 tags: [String] # The tags of the backend
 metadata: Json # The metadata of the backend
 backend: NgBackend # The actual backend
 name: String # The name of the backend
 _loc: EntityLocation # The location of the backend
 id: String # The id of the backend
}

  
type AccessValidatorRef {
 enabled: Boolean 
 excludedPatterns: [String] 
 refs: [String] 
 config: Json 
}

  
"""
User session for private apps
"""
type PrivateAppsUser {
 realm: String # Session realm name
 token: Json # Session tokens (from OAuth)
 expiredAt: Int # Session expiration date
 profile: Json # Session user profile
 lastRefresh: Int # Session last refresh (if OAuth refresh_token supported)
 randomId: String # Session random id
 email: String # Session user email
 createdAt: Int # Creation date of the session
 _loc: EntityLocation # Entity location
 authConfigId: String # Auth module id that created the session
 tags: [String] # Entity tags
 name: String # Entity name
 otoroshiData: String
 metadata: Json # Entity metadata
}

  
"""
A composition of multiple routes with the same plugins
"""
type NgService {
 metadata: Json # The metadata of the service
 client: NgClientConfig # The client config of the service
 name: String # The name of the service
 id: String # The id of the service
 capture: Boolean # Capture http traffic
 description: String # The description of the service
 routes: [NgMinimalRoute] # The routes of the service
 debug_flow: Boolean # Enable report debugging
 export_reporting: Boolean # Export the execution reporting through standard data exporter
 _loc: EntityLocation # The location of the service
 enabled: Boolean # Is the service enabled
 tags: [String] # The tags of the service
 groups: [String] # The groups of the service
}

  
type HealthCheck {
 enabled: Boolean 
 url: String 
}

  
"""
Settings for the snow monkey (chaos engineering)
"""
type SnowMonkeyConfig {
 dryRun: Boolean # Whether or not outages will actualy impact requests
 outageDurationTo: Int # End of outage duration range
 chaosConfig: ChaosConfig # Chaos settings
 timesPerDay: Int # Number of time per day each service will be outage
 outageDurationFrom: Int # Start of outage duration range
 startTime: String # Start time of Snow Monkey each day
 includeUserFacingDescriptors: Boolean # Whether or not user facing apps. will be impacted by Snow Monkey
 targetGroups: [String] # Groups impacted by Snow Monkey. If empty, all groups will be impacted
 enabled: Boolean # Whether or not this config is enabled
 stopTime: String # Stop time of Snow Monkey each day
 outageStrategy: Json # 
}

  
"""
Elasticseach indexation settings
"""
type IndexSettings {
 clientSide: Boolean # Enable index splitting on client side
 interval: Json # Index splitting interval
}

  
type GroupFilter {
 group: String 
 tenant: TenantAccess 
 team: String 
}

  
"""
Settings to generate certificates on the fly
"""
type AutoCert {
 allowed: [String] # allowed domains
 enabled: Boolean # Enable auto cert
 replyNicely: Boolean # Reply TLS error with an auto generated certificate for the domain
 notAllowed: [String] # not allowed domains
 caRef: String
}

  
type RestrictionPath {
 method: String 
 path: String 
}

  
"""
Settings for the http client when http request is forwarded
"""
type NgClientConfig {
 idle_timeout: Int # Timeout on idle connection
 sample_interval: Int # Specify the sliding window time for the circuit breaker in milliseconds, after this time, error count will be reseted
 cache_connection_settings: NgCacheConnectionSettings # Cached connection settings
 call_and_stream_timeout: Int # Specify how long each call should last at most in milliseconds (hard timeout, connection will be closed after that duration)
 custom_timeouts: [NgCustomTimeouts] # Custom timeouts per path
 connection_timeout: Int # Timeout at connection
 call_timeout: Int # Specify how long each call should last at most in milliseconds (soft timeout as it's enforced by the circuit breaker)
 global_timeout: Int # Specify how long the global call (with retries) should last at most in milliseconds
 retry_initial_delay: Int # Specify the delay between two retries. Each retry, the delay is multiplied by the backoff factor
 backoff_factor: Int # Specify the factor to multiply the delay for each retry
 proxy: Json # Web proxy settings for http client
 retries: Int # Specify how many times the client will try to fetch the result of the request after an error before giving up.
 max_errors: Int # Specify how many errors can pass before opening the circuit breaker
}

  
type Target {
 tags: [String] 
 host: String 
 weight: Int 
 metadata: Json 
 protocol: String 
 predicate: Json 
 ipAddress: String
 mtlsConfig: MtlsConfig 
 scheme: String 
}

  
"""
Various web proxy settings for http client
"""
type Proxies {
 elastic: String # Web proxy used to call elastic
 eventsWebhooks: String # Web proxy used to call webhooks
 jwk: String # Web proxy used to fetch jwks
 auth: String # Web proxy used to call OAuth providers
 clevercloud: String # Web proxy used to call clevercloud
 alertEmails: String # Web proxy used to send alert emails
 authority: String # Web proxy used to check authorities
 services: String # Web proxy used to access services targets
}

  
"""
Settings for automatic apikey rotation with grace period
"""
type ApiKeyRotation {
 enabled: Boolean # Rotation enabled
 rotationEvery: Int # Rotate every n hours
 gracePeriod: Int # period (in hours) during which both secrets works
 nextSecret: String
}

  
type CacheConnectionSettings {
 enabled: Boolean 
 queueSize: Int 
}

  
"""
SNI settings for a TCP proxy
"""
type SniSettings {
 enabled: Boolean # SNI extraction enabled
 forwardIfNoMatch: Boolean # 
 forwardsTo: TcpTarget # forwards call to
}

  
"""
Loadbalancing strategy
"""
type LoadBalancing {
 type: String # undefined
 ratio: Int # undefined
}

  
type RedirectionSettings {
 enabled: Boolean 
 code: Int 
 to: String 
}

  
"""
Email location settings
"""
type EmailLocation {
 name: String # Destination name
 email: String # Email address
}

  
"""
An otoroshi model for an organization (otoroshi-ui)
"""
type Tenant {
 description: String # Entity description
 metadata: Json # Entity metadata
 name: String # Entity name
 tags: [String] # Entity tags
 id: String # Entity id
}

  
type ApiDescriptor {
 exposeApi: Boolean 
 openApiDescriptorUrl: String
}

  
type SessionCookieValues {
 httpOnly: Boolean 
 secure: Boolean 
}

  
"""
Settings for connection to a let's encrypt (or ACME) server
"""
type LetsEncryptSettings {
 privateKey: String # Let's encrypt (ACME) private key
 contacts: [String] # Let's encrypt (ACME) contacts
 emails: [String] # Let's encrypt (ACME) contact emails
 enabled: Boolean # Let's encrypt (ACME) enabled
 publicKey: String # Let's encrypt (ACME) public key
 server: String # Let's encrypt (ACME) server
}

  
"""
TLS settings for the http client
"""
type NgTlsConfig {
 enabled: Boolean # Enabled
 certs: [String] # Trusted cert. ids
 loose: Boolean # Loose verification
 trust_all: Boolean # Trust any certificate
 trusted_certs: [String] # Trusted cert. ids
}

  
type ApiKeyRouteMatcher {
 oneTagIn: [String] 
 noneMetaKeysIn: [String] 
 oneMetaIn: Json 
 oneMetaKeyIn: [String] 
 allMetaKeysIn: [String] 
 noneTagIn: [String] 
 allTagsIn: [String] 
 allMetaIn: Json 
 noneMetaIn: Json 
}

  
type JsonPathValidator {
 path: String 
 value: Json 
}

  
"""
A backend representation with it's targets, load balancing and general settings
"""
type NgBackend {
 root: String # The root path of the backend or the full rewrite path
 health_check: String 
 client: NgClientConfig # Client config. of the backend
 load_balancing: LoadBalancing # Loadbalancing config og the backend
 rewrite: Boolean # Does the backend performs a full url rewrite ?
 target_refs: [String] # List of NgStoredBackend ids
 targets: [NgTarget] # The targets of the backend
}

  
type PreRoutingRef {
 enabled: Boolean 
 excludedPatterns: [String] 
 refs: [String] 
 config: Json 
}

  
"""
The settings for http cached connection at host level
"""
type NgCacheConnectionSettings {
 queue_size: Int # How much request can be queue before dropping it
 enabled: Boolean # Is cached connection enabled
}

  
"""
Data exporter settings
"""
type DataExporterConfig {
 desc: String # Description
 _loc: EntityLocation # Entity location
 bufferSize: Int # Number of events in buffer
 jsonWorkers: Int # Number of workers that transform events
 groupDuration: Int # The max duration before sending group
 groupSize: Int # The max size of events group before sending
 type: Json # Entity type
 tags: [String] # Entity tags
 sendWorkers: Int # Number of workers that sends events
 id: String # Id of the exporter
 name: String # Entity name
 metadata: Json # Entity metadata
 config: Json # Exporter config
 projection: Json # Event projection
 enabled: Boolean # Is the exporter enabled
 filtering: DataExporterConfigFiltering # Filtering options
}

  
type CustomHeadersAuthConstraints {
 enabled: Boolean 
 clientIdHeaderName: String
 clientSecretHeaderName: String
}

  
"""
Global TLS settings. The default domain that will be picked if no certificate matches the current request
"""
type TlsSettings {
 trustedCAsServer: [String] # List for CAs trusted by otoroshi when performing TLS termination
 includeJdkCaClient: Boolean # Use known JDK CAs to build trust when performing request from otoroshi to backends
 randomIfNotFound: Boolean # Use a random one
 defaultDomain: String
 includeJdkCaServer: Boolean # Use known JDK CAs to build trust for incoming request
}

  
type Restrictions {
 forbidden: [RestrictionPath] 
 allowed: [RestrictionPath] 
 notFound: [RestrictionPath] 
 allowLast: Boolean 
 enabled: Boolean 
}

  
type IpFiltering {
 whitelist: [String] 
 blacklist: [String] 
}

  
"""
Location of any entity (teams and organization)
"""
type EntityLocation {
 tenant: String # Organization of the current entity
 teams: [String] # Teams of the current entity
}

  """
  Version of the info token
  """
  enum SecComInfoTokenVersion { 
   Legacy
 Latest
  }

  
type Credential {
 certificate: String
 privateKey: String
 certId: String
 useOtoroshiCertificate: Boolean 
}

  
"""
A target where incoming requests will be forwarded
"""
type NgTarget {
 ip_address: String
 protocol: String # Protocol for the target
 predicate: Json # Predicate to choose this target
 tls_config: NgTlsConfig # TLS settings to contact this target
 tls: Boolean # Does the target uses TLS
 port: Int # port of the target
 id: String # id of the target
 weight: Int # The weight of the target when choosing
 hostname: String # hostname of the target
}

  
"""
Settings to extract informations about user agent (for otoroshi events)
"""
type UserAgentSettings {
 enabled: Boolean # User agent extraction enabled
}

type Query {
  adminSessions: [BackOfficeUser] @rest(url: "http://otoroshi-api.oto.tools:9999/api/admin-sessions", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  adminsSimpleTemplate: SimpleOtoroshiAdmin @rest(url: "http://otoroshi-api.oto.tools:9999/api/admins/simple/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  adminsWebauthnTemplate: SimpleOtoroshiAdmin @rest(url: "http://otoroshi-api.oto.tools:9999/api/admins/webauthn/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  apikeys: [ApiKey] @rest(url: "http://otoroshi-api.oto.tools:9999/api/apikeys", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  apikeysId(id : String): ApiKey @rest(url: "http://otoroshi-api.oto.tools:9999/api/apikeys/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  apikeysIdQuotas(id : String): RemainingQuotas @rest(url: "http://otoroshi-api.oto.tools:9999/api/apikeys/${params.id}/quotas", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  apikeysTemplate: ApiKey @rest(url: "http://otoroshi-api.oto.tools:9999/api/apikeys/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  appsSessions: PrivateAppsUser @rest(url: "http://otoroshi-api.oto.tools:9999/api/apps-sessions", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  auths: [Json] @rest(url: "http://otoroshi-api.oto.tools:9999/api/auths", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  authsId(id : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/auths/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  authsTemplate: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/auths/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  backends: [StoredNgBackend] @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/backends", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  backendsId(id : String): StoredNgBackend @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/backends/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  backendsTemplate: StoredNgBackend @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/backends/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  certificates: [Cert] @rest(url: "http://otoroshi-api.oto.tools:9999/api/certificates", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  certificatesByDomain: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/certificates/_by_domain", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  certificatesId(id : String): Cert @rest(url: "http://otoroshi-api.oto.tools:9999/api/certificates/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  certificatesTemplate: Cert @rest(url: "http://otoroshi-api.oto.tools:9999/api/certificates/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  clusterLoginTokensId(id : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/cluster/login-tokens/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  clusterSessionsId(id : String): PrivateAppsUser @rest(url: "http://otoroshi-api.oto.tools:9999/api/cluster/sessions/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  clusterUserTokensId(id : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/cluster/user-tokens/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  dataExporterConfigs: [DataExporterConfig] @rest(url: "http://otoroshi-api.oto.tools:9999/api/data-exporter-configs", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  dataExporterConfigsId(id : String): DataExporterConfig @rest(url: "http://otoroshi-api.oto.tools:9999/api/data-exporter-configs/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  dataExporterConfigsTemplate: DataExporterConfig @rest(url: "http://otoroshi-api.oto.tools:9999/api/data-exporter-configs/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  events: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/events", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  globalconfig: GlobalConfig @rest(url: "http://otoroshi-api.oto.tools:9999/api/globalconfig", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  globalconfigTemplate: GlobalConfig @rest(url: "http://otoroshi-api.oto.tools:9999/api/globalconfig/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  groups: [ServiceGroup] @rest(url: "http://otoroshi-api.oto.tools:9999/api/groups", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  groupsGroupIdStatus(groupId : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/groups/${params.groupId}/status", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  groupsId(id : String): ServiceGroup @rest(url: "http://otoroshi-api.oto.tools:9999/api/groups/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  groupsTemplate: ServiceGroup @rest(url: "http://otoroshi-api.oto.tools:9999/api/groups/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  live: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/live", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  liveHost: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/live/host", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  liveId(id : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/live/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  newApikey: ApiKey @rest(url: "http://otoroshi-api.oto.tools:9999/api/new/apikey", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  newGroup: ServiceGroup @rest(url: "http://otoroshi-api.oto.tools:9999/api/new/group", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  newTcpService: TcpService @rest(url: "http://otoroshi-api.oto.tools:9999/api/new/tcp/service", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  pluginsAll: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/plugins/all", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  routes: [NgRoute] @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/routes", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  routesId(id : String): NgRoute @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/routes/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  routesTemplate: NgRoute @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/routes/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  scripts: [Script] @rest(url: "http://otoroshi-api.oto.tools:9999/api/scripts", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  scriptsId(id : String): Script @rest(url: "http://otoroshi-api.oto.tools:9999/api/scripts/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  scriptsTemplate: Script @rest(url: "http://otoroshi-api.oto.tools:9999/api/scripts/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  services: [NgService] @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/services", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  servicesId(id : String): NgService @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/services/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  servicesServiceIdEvents(serviceId : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/services/${params.serviceId}/events", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  servicesServiceIdLive(serviceId : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/services/${params.serviceId}/live", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  servicesServiceIdResponse(serviceId : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/services/${params.serviceId}/response", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  servicesServiceIdStats(serviceId : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/services/${params.serviceId}/stats", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  servicesServiceIdStatus(serviceId : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/services/${params.serviceId}/status", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  servicesTemplate: NgService @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/services/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  snowmonkeyConfig: SnowMonkeyConfig @rest(url: "http://otoroshi-api.oto.tools:9999/api/snowmonkey/config", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  stats: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/stats", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  statsGlobal: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/stats/global", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  statusGlobal: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/status/global", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  targets: [StoredNgTarget] @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/targets", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  targetsId(id : String): StoredNgTarget @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/targets/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  targetsTemplate: StoredNgTarget @rest(url: "http://otoroshi-api.oto.tools:9999/api/experimental/targets/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tcpServices: [TcpService] @rest(url: "http://otoroshi-api.oto.tools:9999/api/tcp/services", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tcpServicesId(id : String): TcpService @rest(url: "http://otoroshi-api.oto.tools:9999/api/tcp/services/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tcpTemplate: TcpService @rest(url: "http://otoroshi-api.oto.tools:9999/api/tcp/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  teams: [Team] @rest(url: "http://otoroshi-api.oto.tools:9999/api/teams", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  teamsId(id : String): Team @rest(url: "http://otoroshi-api.oto.tools:9999/api/teams/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  teamsTemplate: Team @rest(url: "http://otoroshi-api.oto.tools:9999/api/teams/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tenants: [Tenant] @rest(url: "http://otoroshi-api.oto.tools:9999/api/tenants", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tenantsId(id : String): Tenant @rest(url: "http://otoroshi-api.oto.tools:9999/api/tenants/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tenantsTemplate: Tenant @rest(url: "http://otoroshi-api.oto.tools:9999/api/tenants/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tunnels: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/tunnels", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tunnelsInfos: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/tunnels/infos", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tunnelsRegister: Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/tunnels/register", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  tunnelsTunnelIdRelay(tunnelId : String): Json @rest(url: "http://otoroshi-api.oto.tools:9999/api/tunnels/${params.tunnelId}/relay", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  verifiers: [GlobalJwtVerifier] @rest(url: "http://otoroshi-api.oto.tools:9999/api/verifiers", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  verifiersId(id : String): GlobalJwtVerifier @rest(url: "http://otoroshi-api.oto.tools:9999/api/verifiers/${params.id}", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
  verifiersTemplate: GlobalJwtVerifier @rest(url: "http://otoroshi-api.oto.tools:9999/api/verifiers/_template", method: "GET", headers: "{\"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW4tYXBpLWFwaWtleS1pZDphZG1pbi1hcGktYXBpa2V5LXNlY3JldA==\"}")
}