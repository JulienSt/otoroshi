---
# Source: otoroshi/charts/redis/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: true
metadata:
  name: my-otoroshi-redis
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
---
# Source: otoroshi/templates/rbac.yaml
kind: ServiceAccount
apiVersion: v1
metadata:
  name: otoroshi-admin-user
  labels:
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
---
# Source: otoroshi/charts/redis/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-otoroshi-redis-configuration
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
data:
  redis.conf: |-
    # User-supplied common configuration:
    # Enable AOF https://redis.io/topics/persistence#append-only-file
    appendonly yes
    # Disable RDB persistence, AOF persistence already enabled.
    save ""
    # End of common configuration
  master.conf: |-
    dir /data
    # User-supplied master configuration:
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    # End of master configuration
  replica.conf: |-
    dir /data
    slave-read-only yes
    # User-supplied replica configuration:
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    # End of replica configuration
---
# Source: otoroshi/charts/redis/templates/health-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-otoroshi-redis-health
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
data:
  ping_readiness_local.sh: |-
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    export REDISCLI_AUTH="$REDIS_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
  ping_liveness_local.sh: |-
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    export REDISCLI_AUTH="$REDIS_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$response" != "PONG" ] && [ "$response" != "LOADING Redis is loading the dataset in memory" ]; then
      echo "$response"
      exit 1
    fi
  ping_readiness_master.sh: |-
    #!/bin/bash

    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    export REDISCLI_AUTH="$REDIS_MASTER_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h $REDIS_MASTER_HOST \
        -p $REDIS_MASTER_PORT_NUMBER \
        ping
    )
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
  ping_liveness_master.sh: |-
    #!/bin/bash

    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    export REDISCLI_AUTH="$REDIS_MASTER_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h $REDIS_MASTER_HOST \
        -p $REDIS_MASTER_PORT_NUMBER \
        ping
    )
    if [ "$response" != "PONG" ] && [ "$response" != "LOADING Redis is loading the dataset in memory" ]; then
      echo "$response"
      exit 1
    fi
  ping_readiness_local_and_master.sh: |-
    script_dir="$(dirname "$0")"
    exit_status=0
    "$script_dir/ping_readiness_local.sh" $1 || exit_status=$?
    "$script_dir/ping_readiness_master.sh" $1 || exit_status=$?
    exit $exit_status
  ping_liveness_local_and_master.sh: |-
    script_dir="$(dirname "$0")"
    exit_status=0
    "$script_dir/ping_liveness_local.sh" $1 || exit_status=$?
    "$script_dir/ping_liveness_master.sh" $1 || exit_status=$?
    exit $exit_status
---
# Source: otoroshi/charts/redis/templates/scripts-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-otoroshi-redis-scripts
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
data:
  start-master.sh: |
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    if [[ ! -f /opt/bitnami/redis/etc/master.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/master.conf /opt/bitnami/redis/etc/master.conf
    fi
    if [[ ! -f /opt/bitnami/redis/etc/redis.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/redis.conf /opt/bitnami/redis/etc/redis.conf
    fi
    ARGS=("--port" "${REDIS_PORT}")
    ARGS+=("--protected-mode" "no")
    ARGS+=("--include" "/opt/bitnami/redis/etc/redis.conf")
    ARGS+=("--include" "/opt/bitnami/redis/etc/master.conf")
    exec redis-server "${ARGS[@]}"
  start-replica.sh: |
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    if [[ ! -f /opt/bitnami/redis/etc/replica.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/replica.conf /opt/bitnami/redis/etc/replica.conf
    fi
    if [[ ! -f /opt/bitnami/redis/etc/redis.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/redis.conf /opt/bitnami/redis/etc/redis.conf
    fi
    ARGS=("--port" "${REDIS_PORT}")
    ARGS+=("--slaveof" "${REDIS_MASTER_HOST}" "${REDIS_MASTER_PORT_NUMBER}")
    ARGS+=("--protected-mode" "no")
    ARGS+=("--include" "/opt/bitnami/redis/etc/redis.conf")
    ARGS+=("--include" "/opt/bitnami/redis/etc/replica.conf")
    exec redis-server "${ARGS[@]}"
---
# Source: otoroshi/templates/rbac.yaml
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: otoroshi-admin-user
  labels:
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
rules:
  - apiGroups:
      - ""
    resources:
      - services
      - endpoints
      - secrets
      - configmaps
      - deployments
      - pods
      - namespaces
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - secrets
      - configmaps
    verbs:
      - update
      - update
      - create
      - delete
  - apiGroups:
      - extensions
    resources:
      - ingresses
      - ingressclasses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - extensions
    resources:
      - ingresses/status
    verbs:
      - update
  - apiGroups:
      - admissionregistration.k8s.io
    resources:
      - validatingwebhookconfigurations
      - mutatingwebhookconfigurations
    verbs:
      - get
      - update
      - patch
  - apiGroups:
      - proxy.otoroshi.io
    resources:
      - service-groups
      - service-descriptors
      - apikeys
      - certificates
      - global-configs
      - jwt-verifiers
      - auth-modules
      - scripts
      - tcp-services
      - admins
      - organizations
      - teams
    verbs:
      - get
      - list
      - watch
---
# Source: otoroshi/templates/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: otoroshi-admin-user
  labels:
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: otoroshi-admin-user
subjects:
- kind: ServiceAccount
  name: otoroshi-admin-user
  namespace: otoroshi
---
# Source: otoroshi/charts/redis/templates/headless-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-otoroshi-redis-headless
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/instance: my-otoroshi
---
# Source: otoroshi/charts/redis/templates/master/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-otoroshi-redis-master
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: master
spec:
  type: ClusterIP
  
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
      nodePort: null
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/component: master
---
# Source: otoroshi/charts/redis/templates/replicas/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-otoroshi-redis-replicas
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: replica
spec:
  type: ClusterIP
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
      nodePort: null
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/component: replica
---
# Source: otoroshi/templates/deployment.yaml
apiVersion: v1
kind: Service
metadata:
  name: otoroshi-service
  namespace: otoroshi
  labels:
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
spec:
  selector:
    app.kubernetes.io/name: otoroshi
    app.kubernetes.io/instance: my-otoroshi
  ports:
  - port: 8080
    name: "http"
    targetPort: "http"
  - port: 8443
    name: "https"
    targetPort: "https"
---
# Source: otoroshi/templates/deployment.yaml
apiVersion: v1
kind: Service
metadata:
  name: otoroshi-api-service
  namespace: otoroshi
  labels:
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
spec:
  selector:
    app.kubernetes.io/name: otoroshi
    app.kubernetes.io/instance: my-otoroshi
  ports:
  - port: 8080
    name: "http"
    targetPort: "http"
  - port: 8443
    name: "https"
    targetPort: "https"
---
# Source: otoroshi/templates/deployment.yaml
apiVersion: v1
kind: Service
metadata:
  name: otoroshi-external-service
  namespace: otoroshi
  labels:
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
spec:
  type: LoadBalancer
  selector:
    app.kubernetes.io/name: otoroshi
    app.kubernetes.io/instance: my-otoroshi
  ports:
  - port: 80
    name: "http"
    targetPort: "http"
  - port: 443
    name: "https"
    targetPort: "https"
---
# Source: otoroshi/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: otoroshi-deployment
  namespace: otoroshi
  labels:
    app.kubernetes.io/name: otoroshi
    helm.sh/chart: otoroshi-1.0.0
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
  annotations:
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: otoroshi
      app.kubernetes.io/instance: my-otoroshi
  replicas: 2
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/name: otoroshi
        app.kubernetes.io/instance: my-otoroshi
    spec:
      serviceAccountName: otoroshi-admin-user
      terminationGracePeriodSeconds: 60
      hostNetwork: false
      containers:
      - image: maif/otoroshi:1.5.0-beta.8-jdk11
        imagePullPolicy: IfNotPresent
        name: otoroshi
        ports:
          - containerPort: 8080
            name: "http"
            protocol: TCP
          - containerPort: 8443
            name: "https"
            protocol: TCP
        env:
          - name: APP_STORAGE_ROOT
            value: otoroshi
          - name: OTOROSHI_INITIAL_ADMIN_PASSWORD
            value: password
          - name: APP_DOMAIN
            value: oto.tools
          - name: APP_STORAGE
            value: lettuce
          - name: REDIS_URL
            # value: redis://otorosi-redis-master:6379
            value: 'redis://my-otoroshi-redis-master:6379'
          - name: ADMIN_API_CLIENT_ID
            value: admin-api-apikey-id
          - name: ADMIN_API_CLIENT_SECRET
            value: admin-api-apikey-secret
          - name: ADMIN_API_ADDITIONAL_EXPOSED_DOMAIN
            value: otoroshi-api-service.otoroshi.svc.cluster.local
          - name: OTOROSHI_SECRET
            value: secret-secret-secret-secret-secret
          - name: HEALTH_LIMIT
            value: "5000"
          - name: SSL_OUTSIDE_CLIENT_AUTH
            value: Want
          - name: HTTPS_WANT_CLIENT_AUTH
            value: "true"
          - name: OTOROSHI_INITIAL_CUSTOMIZATION
            value: >
              {
                "config":{
                  "tlsSettings": {
                    "defaultDomain": "www.oto.tools",
                    "randomIfNotFound": false
                  },
                  "scripts":{
                    "enabled":true,
                    "sinkRefs":[
                      "cp:otoroshi.plugins.jobs.kubernetes.KubernetesAdmissionWebhookCRDValidator",
                      "cp:otoroshi.plugins.jobs.kubernetes.KubernetesAdmissionWebhookSidecarInjector"
                    ],
                    "sinkConfig": {},
                    "jobRefs":[
                      "cp:otoroshi.plugins.jobs.kubernetes.KubernetesOtoroshiCRDsControllerJob"
                    ],
                    "jobConfig":{
                      "KubernetesConfig": {
                        "trust": false,
                        "namespaces": [
                          "*"
                        ],
                        "labels": {},
                        "namespacesLabels": {},
                        "ingressClasses": [
                          "otoroshi"
                        ],
                        "defaultGroup": "default",
                        "ingresses": false,
                        "crds": true,
                        "coreDnsIntegration": false,
                        "coreDnsIntegrationDryRun": false,
                        "kubeLeader": false,
                        "restartDependantDeployments": false,
                        "watch": false,
                        "syncDaikokuApikeysOnly": false,
                        "kubeSystemNamespace": "kube-system",
                        "coreDnsConfigMapName": "coredns",
                        "coreDnsDeploymentName": "coredns",
                        "corednsPort": 53,
                        "otoroshiServiceName": "otoroshi-service",
                        "otoroshiNamespace": "otoroshi",
                        "clusterDomain": "cluster.local",
                        "syncIntervalSeconds": 60,
                        "coreDnsEnv": null,
                        "watchTimeoutSeconds": 60,
                        "watchGracePeriodSeconds": 5,
                        "mutatingWebhookName": "otoroshi-admission-webhook-injector",
                        "validatingWebhookName": "otoroshi-admission-webhook-validation",
                        "templates": {
                          "service-group": {},
                          "service-descriptor": {},
                          "apikeys": {},
                          "global-config": {},
                          "jwt-verifier": {},
                          "tcp-service": {},
                          "certificate": {},
                          "auth-module": {},
                          "script": {},
                          "organizations": {},
                          "teams": {},
                          "webhooks": {
                            "flags": {
                              "requestCert": true,
                              "originCheck": true,
                              "tokensCheck": true,
                              "displayEnv": false,
                              "tlsTrace": false
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
          - name: JAVA_OPTS
            value: '-Xms2g -Xmx4g -XX:+UseContainerSupport -XX:MaxRAMPercentage=80.0'
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          failureThreshold: 1
          initialDelaySeconds: 60
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 2
        livenessProbe:
          httpGet:
            path: /live
            port: 8080
          failureThreshold: 3
          initialDelaySeconds: 60
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 2
        resources:
          limits:
            memory: 1Gi
          requests:
            memory: 1Gi
---
# Source: otoroshi/charts/redis/templates/master/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-otoroshi-redis-master
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: master
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: redis
      app.kubernetes.io/instance: my-otoroshi
      app.kubernetes.io/component: master
  serviceName: my-otoroshi-redis-headless
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/name: redis
        helm.sh/chart: redis-15.0.0
        app.kubernetes.io/instance: my-otoroshi
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: master
      annotations:
        checksum/configmap: 6caefb849410120590ffbac44ff89d92d2abe005e7ccd145495096dc059eb841
        checksum/health: c85b57a7f3d2d3b0af378088c0f9f3c8084412b1965b6d534bb2fa542f89c382
        checksum/scripts: ee67e58d220b0d88a31f7ceb3b7ece5d0b699a5f80d84726ea3798ffc49e2e29
        checksum/secret: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    spec:
      
      securityContext:
        fsGroup: 1001
      serviceAccountName: my-otoroshi-redis
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: redis
                    app.kubernetes.io/instance: my-otoroshi
                    app.kubernetes.io/component: master
                namespaces:
                  - "otoroshi"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      terminationGracePeriodSeconds: 30
      containers:
        - name: redis
          image: docker.io/bitnami/redis:6.2.5-debian-10-r11
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          command:
            - /bin/bash
          args:
            - -c
            - /opt/bitnami/scripts/start-scripts/start-master.sh
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: REDIS_REPLICATION_MODE
              value: master
            - name: ALLOW_EMPTY_PASSWORD
              value: "yes"
            - name: REDIS_TLS_ENABLED
              value: "no"
            - name: REDIS_PORT
              value: "6379"
          ports:
            - name: redis
              containerPort: 6379
          livenessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            # One second longer than command timeout should prevent generation of zombie processes.
            timeoutSeconds: 6
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_liveness_local.sh 5
          readinessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 2
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_readiness_local.sh 1
          resources:
            limits: {}
            requests: {}
          volumeMounts:
            - name: start-scripts
              mountPath: /opt/bitnami/scripts/start-scripts
            - name: health
              mountPath: /health
            - name: redis-data
              mountPath: /data
              subPath: 
            - name: config
              mountPath: /opt/bitnami/redis/mounted-etc
            - name: redis-tmp-conf
              mountPath: /opt/bitnami/redis/etc/
            - name: tmp
              mountPath: /tmp
      volumes:
        - name: start-scripts
          configMap:
            name: my-otoroshi-redis-scripts
            defaultMode: 0755
        - name: health
          configMap:
            name: my-otoroshi-redis-health
            defaultMode: 0755
        - name: config
          configMap:
            name: my-otoroshi-redis-configuration
        - name: redis-tmp-conf
          emptyDir: {}
        - name: tmp
          emptyDir: {}
  volumeClaimTemplates:
    - metadata:
        name: redis-data
        labels:
          app.kubernetes.io/name: redis
          app.kubernetes.io/instance: my-otoroshi
          app.kubernetes.io/component: master
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: otoroshi/charts/redis/templates/replicas/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-otoroshi-redis-replicas
  namespace: "otoroshi"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-15.0.0
    app.kubernetes.io/instance: my-otoroshi
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: replica
spec:
  replicas: 3
  selector:
    matchLabels:
      app.kubernetes.io/name: redis
      app.kubernetes.io/instance: my-otoroshi
      app.kubernetes.io/component: replica
  serviceName: my-otoroshi-redis-headless
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/name: redis
        helm.sh/chart: redis-15.0.0
        app.kubernetes.io/instance: my-otoroshi
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: replica
      annotations:
        checksum/configmap: 6caefb849410120590ffbac44ff89d92d2abe005e7ccd145495096dc059eb841
        checksum/health: c85b57a7f3d2d3b0af378088c0f9f3c8084412b1965b6d534bb2fa542f89c382
        checksum/scripts: ee67e58d220b0d88a31f7ceb3b7ece5d0b699a5f80d84726ea3798ffc49e2e29
        checksum/secret: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    spec:
      
      securityContext:
        fsGroup: 1001
      serviceAccountName: my-otoroshi-redis
      affinity:
        podAffinity:
          
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: redis
                    app.kubernetes.io/instance: my-otoroshi
                    app.kubernetes.io/component: replica
                namespaces:
                  - "otoroshi"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
          
      terminationGracePeriodSeconds: 30
      containers:
        - name: redis
          image: docker.io/bitnami/redis:6.2.5-debian-10-r11
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          command:
            - /bin/bash
          args:
            - -c
            - /opt/bitnami/scripts/start-scripts/start-replica.sh
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: REDIS_REPLICATION_MODE
              value: slave
            - name: REDIS_MASTER_HOST
              value: my-otoroshi-redis-master-0.my-otoroshi-redis-headless.otoroshi.svc.cluster.local
            - name: REDIS_MASTER_PORT_NUMBER
              value: "6379"
            - name: ALLOW_EMPTY_PASSWORD
              value: "yes"
            - name: REDIS_TLS_ENABLED
              value: "no"
            - name: REDIS_PORT
              value: "6379"
          ports:
            - name: redis
              containerPort: 6379
          livenessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 6
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_liveness_local_and_master.sh 5
          readinessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 2
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_readiness_local_and_master.sh 1
          resources:
            limits: {}
            requests: {}
          volumeMounts:
            - name: start-scripts
              mountPath: /opt/bitnami/scripts/start-scripts
            - name: health
              mountPath: /health
            - name: redis-data
              mountPath: /data
              subPath: 
            - name: config
              mountPath: /opt/bitnami/redis/mounted-etc
            - name: redis-tmp-conf
              mountPath: /opt/bitnami/redis/etc
      volumes:
        - name: start-scripts
          configMap:
            name: my-otoroshi-redis-scripts
            defaultMode: 0755
        - name: health
          configMap:
            name: my-otoroshi-redis-health
            defaultMode: 0755
        - name: config
          configMap:
            name: my-otoroshi-redis-configuration
        - name: redis-tmp-conf
          emptyDir: {}
  volumeClaimTemplates:
    - metadata:
        name: redis-data
        labels:
          app.kubernetes.io/name: redis
          app.kubernetes.io/instance: my-otoroshi
          app.kubernetes.io/component: replica
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: otoroshi/templates/cert.yaml
apiVersion: proxy.otoroshi.io/v1
kind: Certificate
metadata:
  name: otoroshi-service-certificate
  namespace: otoroshi
  labels:
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
spec:
  description: "certificate for otoroshi-service"
  autoRenew: true
  csr:
    issuer: CN=Otoroshi Root
    hosts: 
    - otoroshi-service
    - otoroshi-service.otoroshi.svc.cluster.local
    - otoroshi-api-service.otoroshi.svc.cluster.local
    - otoroshi.oto.tools
    - otoroshi-api.oto.tools
    - privateapps.oto.tools
    key:
      algo: rsa
      size: 2048
    subject: uid=otoroshi-service-cert, O=Otoroshi
    client: false
    ca: false
    duration: 31536000000
    signatureAlg: SHA256WithRSAEncryption
    digestAlg: SHA-256
---
# Source: otoroshi/templates/webhooks.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: otoroshi-admission-webhook-validation
  namespace: otoroshi
  labels:
    app.kubernetes.io/managed-by: "Helm"
    meta.helm.sh/release-namespace: otoroshi
    meta.helm.sh/release-name: my-otoroshi
    app: otoroshi
    component: otoroshi-validation-webhook
webhooks:
  - name: otoroshi-admission-webhook.otoroshi.io
    rules:
      - operations: 
          - "CREATE"
          - "UPDATE"
        apiGroups: 
          - "proxy.otoroshi.io"
        apiVersions: 
          - "*"
        resources: 
          - "*"
        scope: "Namespaced"
    clientConfig:
      # url: "https://otoroshi-kubernetes-admission-webhook.otoroshi.svc.cluster.local:8443/apis/webhooks/validation"
      service:
        name: otoroshi-service
        namespace: otoroshi
        path: "/apis/webhooks/validation"
        port: 8443
      caBundle: "" # injected at runtime
    failurePolicy: Ignore
    sideEffects: None
    admissionReviewVersions: 
      - "v1"
