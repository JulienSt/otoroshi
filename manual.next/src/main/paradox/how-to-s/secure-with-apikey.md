# Secure an api with api keys

### Cover by this tutorial
- [About the downstream example service](#about-the-downstream-example-service)
- [Create a simple service](#create-a-simple-service)
- [Secure routes with api key](#secure-an-api-with-apikey)
- [Generate an api key to request secure services](#generate-an-api-key-to-request-secure-services)
- [Override defaults headers names for a service](#override-defaults-headers-names-for-a-service)
- [Accept only api keys with expected values](#accept-only-api-keys-with-expected-values)

@@@ warning
TODO - schema
@@@

### Download Otoroshi

Let's start by downloading the latest Otoroshi
```sh
curl -L -o otoroshi.jar 'https://github.com/MAIF/otoroshi/releases/download/v1.5.0-dev/otoroshi.jar'
```

By default, Otoroshi starts with domain `oto.tools` that targets `127.0.0.1`

Run Otoroshi
```sh
java -Dapp.adminPassword=password -Dhttp.port=9999 -Dhttps.port=9998 -jar otoroshi.jar 
```

Log to Otoroshi at http://otoroshi.oto.tools:9999/ with `admin@otoroshi.io/password`

### About the downstream example service

In these tutorials, we will create a simple service which route to *https://mirror.otoroshi.io/*

This downstream service is a very good entry point to test the functionality of Otoroshi services, as it will return the content of all requests received (included headers, body, etc.).

### Create a simple service 

1. Navigate to http://otoroshi.oto.tools:9999/bo/dashboard/lines/prod/services/service_596bb0d1-9eb5-40fe-b521-9d138fe9ec85
2. Jump to `Service exposition settings` and add *http://myservice.oto.tools* as `Exposed domain`
3. Jump to `Service targets` and add *https://mirror.otoroshi.io/* as `Target 1`
4. Jump to the `URL Patterns` section
5. Enable your service as `Public UI`
6. Open a new tab and navigate to *http://myservice.oto.tools:9999/*

With this configuration, all routes are public, wihtout any authentication needed.

### Secure routes with api key

With the previous configuration, all routes are public. 

In our case, we want to secure all routes prefix with `/api`.

Let's return to the `URL Patterns` section. Click on `Make service a private api`. This button automatically add `/api` as default in `Private patterns` array. (Note that the field supports regex like. In our case, `/api.*` covers all routes starting by */api*).

Save your app and navigate to *http://myservice.oto.tools:9999/api/test* again. If the service is configured, you should have a `Service Not found error`, and a success call, in the case you navigate to any other routes which are not starting by `/api/*` like *http://myservice.oto.tools:9999/test/bar*

This expected error on the `/api/test`, throws by the URL Patterns, indicate to the client that an api key is required to access to the downstream service.

### Generate an api key to request secure services

Navigate to *http://otoroshi.oto.tools:9999/bo/dashboard/apikeys/add* or when clicking on the `Add apikey` button on the sidebar.

The only required fields of an Otoroshi api key are : 
* `ApiKey id`
* `ApiKey Secret`
* `ApiKey Name`

These fields are automatically generated by Otoroshi. However, you can override these values and indicate an additional description.

To simplify the rest of the tutorial, set the values:
* `my-first-api-key-id` as `ApiKey Id`
* `my-first-api-key-secret` as `ApiKey Secret`


Click on `Create and stay on this ApiKey` button at the bottom of the page.

Now you created the key, it's time to call our previous generated service with it.

Otoroshi supports two methods to achieve that. 
Once by passing Otoroshi api key in two headers : *Otoroshi-Client-Id* and *Otoroshi-Client-Secret* (these headers names can be override on each service).
And the second by passing Otoroshi api key in the authentication Header (basically the *Authorization* header) as a basic encoded value.

Let's ahead and call our service :
```sh
curl -X GET \
-H 'Otoroshi-Client-Id: my-first-api-key-id' \
-H 'Otoroshi-Client-Secret: my-first-api-key-secret' \
http://myservice.oto.tools:9999/api/test --include
```
And with the second method :

```sh
curl -X GET \
-H 'Authorization: Basic bXktZmlyc3QtYXBpLWtleS1pZDpteS1maXJzdC1hcGkta2V5LXNlY3JldA==' \
http://myservice.oto.tools:9999/api/test --include
```

> Tips : To easily fill your headers, you can jump to the `Call examples` section in each api key view. In this section the header names are the default values and the service url is not set. You have to adapt these lines to your case. 

### Override defaults headers names for a service

In some case, we want to change the defaults headers names (and it's a quite good idea).

Let's start by navigate to the `Api keys Constraints` section from the edit page of our sercice.

The first values to change are the headers names used to read the api key from client. Start by set :
* `api-key-header-id` as `Custom client id header name`
* `api-key-header-secret` as `Custom client secret header name`

Save the service, and call the service again.

```sh
curl -X GET \
-H 'Otoroshi-Client-Id: my-first-api-key-id' \
-H 'Otoroshi-Client-Secret: my-first-api-key-secret' \
http://myservice.oto.tools:9999/api/test --include
```

This should output an error because Otoroshi are expecting the api keys in other headers.

```json
{
  "Otoroshi-Error": "No ApiKey provided"
}
```

Call one again the service but with the changed headers names.

```sh
curl -X GET \
-H 'api-key-header-id: my-first-api-key-id' \
-H 'api-key-header-secret: my-first-api-key-secret' \
http://myservice.oto.tools:9999/api/test --include
```

With this configuration, all others default services will accept the api keys with the `Otoroshi-Client-Id` and `Otoroshi-Client-Secret` headers, while our service, will accept the `api-key-header-id` and `api-key-header-secret` headers.

### Accept only api keys with expected values

By default, a secure service only accepts requests with api key. But all generated api keys are eligible to call our service and in some case, we want authorize only a couple of api keys.

One feature of Otoroshi is to restrict the list of accepted api keys by giving a list of `metadatas` or/and `tags`. Each api key has a list of `tags` and `metadatas`, which can be used by Otoroshi to forward or not a call with an api key. All api key metadatas/tags can be forward to your service (see `Otoroshi exchange protocol` section of a service to get more information about *Send info. token*).

Let's starting by accept only the api keys which come with the tag of `otoroshi` as value.

Jump to the last part of the `Api Keys Constraints` section, call `Routing constraints` (these constraints are used to route a call to a service, only if all constraint are validated).

In our first case, set `otoroshi` in `One Tag in` array and save the service.
Then call our service with :
```sh
curl -X GET \
-H 'Otoroshi-Client-Id: my-first-api-key-id' \
-H 'Otoroshi-Client-Secret: my-first-api-key-secret' \
http://myservice.oto.tools:9999/api/test --include
```

This should output :
```json
// Error reason : Our api key doesn't contains the expected tag.
{
  "Otoroshi-Error": "Bad API key"
}
```

Navigate to the edit page of our api key, and jump to the `Metadata and tags` section.
In this section, add `otoroshi` in `Tags` array, then save the api key. Call once again your call and you will normally get a successful response of our downstream service.

In this example, we have restricted our service to be callable only with keys that have `otoroshi` as a tag.

But Otoroshi provides others behaviours. For each behaviour, *Api key used should*:
* `All Tags in` : have all of the following tags
* `No Tags in` : not have one of the following tags
* `One Tag in` : have at least one of the following tags
---
* `All Meta. in` : have all of the following metadata entries
* `No Meta. in` : not have one of the following metadata entries
* `One Meta. in` : have at least one of the following metadata entries
----
* `One Meta key in` : have at least one of the following key in metadata
* `All Meta key in` : have all of the following keys in metadata
* `No Meta key in` : not have one of the following keys in metadata